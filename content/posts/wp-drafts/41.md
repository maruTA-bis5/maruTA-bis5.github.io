---
title: jjug ccc 2014 spring
date: 
draft: true 
categories: 
tags:
---

```
2014-05-18 09:24:14 +0900: test
2014-05-18 09:24:27 +0900: test
2014-05-18 09:25:31 +0900: バッテリー残量９５%で残り1時間半とかヤバすぎるだろこいつ
2014-05-18 09:29:14 +0900: しっかし新宿駅から会場まで予定してた時間の倍かかるとは思わなかったな
2014-05-18 09:29:48 +0900: 。○（敗因は新宿駅の出口がまったく別の方向だったことと地図を確認しなかったこと）
2014-05-18 09:29:54 +0900: ＿人人人人人人＿
＞　自業自得　＜
￣^Y^Y^Y^Y^Y^￣
2014-05-18 09:30:20 +0900: バッテリー11時まで持てばいい方かorz
2014-05-18 09:30:35 +0900: JJUG総会始まった
2014-05-18 09:30:53 +0900: 思ったよりしっかりしてるな
2014-05-18 09:31:18 +0900: CCCは年2回あるのか
2014-05-18 09:32:30 +0900: なるほど、春と秋にやるのね。秋もいけたらいこうかな
2014-05-18 09:33:27 +0900: ナイトセミナーはテーマいろいろ、初心者向けから特定ジャンルまで様々。毎月第2水曜日くらいに日本オラクル本社でやってるそうな
2014-05-18 09:34:04 +0900: やばいoshaburiはかどる
2014-05-18 09:36:15 +0900: バッテリー少し落ち着いてきた感じって入力した途端に残り時間減ったよつらい
2014-05-18 09:37:35 +0900: ヤバいこいつバッテリー容量3割くらいになってる　カタログ8時間だから・・・
2014-05-18 09:38:19 +0900: 既に残り８０%
2014-05-18 09:59:56 +0900: JJUG会員の条件はML登録
2014-05-18 10:00:12 +0900: イベント情報はTwitter,FB抱けでも確認可能
2014-05-18 10:00:43 +0900: JJUGホームページ、右上のJJUGについてから「入会案内」を参照
2014-05-18 10:01:07 +0900: /*********ここから #ccc_k1 *************************/
2014-05-18 10:06:32 +0900: 桜庭さん @skrb
2014-05-18 10:11:45 +0900: Lambda以外の変更も出たりは言ったりしているけれど、結局注目されるのはLambdaっていうのがJava8リリース
2014-05-18 10:15:30 +0900: リファクタリング本とかにある制御構造が1つだけになるようにメソッドを抽出するのはよくやるけど、それはほんとうにわかりやすい？
2014-05-18 10:16:15 +0900: Lambdaは一般的に並列実効のために使われる。でも並列に出きるところなんてそんなに多くない。
2014-05-18 10:17:45 +0900: 内部イテレータとλ式(関数）で表現で切るのって言うのが重要。

for(Hoge hoge : hoges) {
if (hoge.isA()) {
for(HogeHoge hogehoge : hoge) {
if (hogehoge.isB()) {
hogehoge.fuga();
}
}
}

2014-05-18 10:18:00 +0900: hoges.forEach(/**/)
2014-05-18 10:18:41 +0900: forEachは甘え。.filter(), .flatMap(), filter(), collect()などで書き換えるのが最終形
2014-05-18 10:19:07 +0900: ＿人人人人人人＿
＞　for文禁止　＜
￣^Y^Y^Y^Y^Y^￣ #極論
2014-05-18 10:19:20 +0900: いうてfor文禁止できればいいかんじ
2014-05-18 10:19:53 +0900: Lambdaについて詳細はK2にて
2014-05-18 10:20:35 +0900: パフォーマンスがなかなか上がらないなら、コードを見るより情報を収集する。Java Flight Recorder, Java Mission Controlをつかおう
2014-05-18 10:21:13 +0900: Flight Recorderは落ちたときにログを見る、Mission Controlは実行中に情報を見る
2014-05-18 10:22:22 +0900: jconsole(J2SE5) -> VisualVM(JavaSE6) -> Mission Control(JavaSE8)
2014-05-18 10:25:15 +0900: Misson ControlはOpenJDKには搭載されていない。残念
2014-05-18 10:25:38 +0900: Flight Recorderは機動オプションで設定可能。落ちたらヤバいシステムで有効にしておく問い以下と
2014-05-18 10:27:14 +0900: 処理速度が上がらない？Pararell Stream使って並列処理しましょう。
ヒープがヤバい?JavaSE8使ってヒープ使用料を削減しましょう。あとPermanent領域は廃止されましたよ
2014-05-18 10:27:27 +0900: Date/Calendarってつかいにくいよね
2014-05-18 10:28:37 +0900: 日付行ったり来たりするのにSImpleDateFormat->Date->Calendar->Date->SimpleDateFormatは非常に面倒(~Java7)
2014-05-18 10:29:15 +0900: そこでDate&Time APIですよ。

Date/CalendarはUnix Time。
Date&Time APIはISO8601　これでよくならないわけがない
2014-05-18 10:30:03 +0900: Date&Time APIはImmutable（Date/CalendarがMutable名のが驚き）
演算処理モカなり楽になってるらしい
2014-05-18 10:31:44 +0900: Date&Time APIは残念ながらクラスが量産されてしまっている。

日にちと時間が別、LocalとOffsetとZoned、Date/DateTime、Year,YearMonth,MonthDay,Second,Instant(Unix Time), etc...
2014-05-18 10:35:29 +0900: 静的コード解析は、どうしても情報が不十分だったりする。そこでAnnotatioですよ
2014-05-18 10:36:36 +0900: Time Annotation はコードチェッカー向けといえる

@Untained String query;
List<@NonNull String.> strings;
myGraph = (@Immutable Graph) tmpGraph;
class ROList implements @ReadOnly List {}
2014-05-18 10:38:05 +0900: 前ツイのアノテーションは実際に実装しているわけではないけど、こういう書き方が出きるってこと。Checker Frameworkでは実相が始まっている用だ。

JavaSE8は実装はしていない。かけるところが増えたって言うだけの話
2014-05-18 10:39:53 +0900: Repeating Annotation(同じアノテーションが複数かける）もJavaSE8で
2014-05-18 10:40:38 +0900: Factoty Methodパターンでパラメータをアノテーションで渡すとかも出きるように
2014-05-18 10:40:55 +0900: GUIはこれからJavaFXへ
2014-05-18 10:42:15 +0900: Swing->JavaFXに置き換えられるかも。Swingはこれから消えていく運命に

JavaFXならアニメーションもバリバリかけるのでプレゼンツールにも使える
2014-05-18 10:43:13 +0900: JavaFXはGUI構造をXML(FXML)で定義できる。Look&FeelはCSS、LogicはJavaでと言う感じの住み分け。他の言語にやっと追いついたって感じ
2014-05-18 10:45:41 +0900: うめこみブラウザー、ムービー、3DCGなどいろいろできるJavFX
2014-05-18 10:51:06 +0900: サーバー再度JSのための実装Nashornは、InvokeDynamicを使う新しいJSエンジン。SunSpiderのベンチマークでははJava7の半分位で実行できる
2014-05-18 10:51:14 +0900: 半分以下
2014-05-18 10:52:08 +0900: ちなみにChromeの倍位かかる
2014-05-18 10:52:32 +0900: ちなみにIE10と同じくらい。実用的なレベルといえる
2014-05-18 10:54:24 +0900: JavaSE8でプログラムスタイルが変わる。とくにStreamAPI。Lambda禁止と戦おう。
2014-05-18 10:55:15 +0900: /********* ここから #ccc_k2 ***************/

2014-05-18 11:10:06 +0900: Java8の2つのフィーチャーについて話す

Lambda式とStreamAPI
Lambda
Lambda式はfunctionalである。
関数はぱらめーたとreturn である。Java8以前はメソッドとしてしか実装できなかったが、引数で渡せるようになった？
2014-05-18 11:13:00 +0900: あるオブジェクトを何らかの規則でソートしたいとき、Collections.sortの第2引数でその方法を指定する。

2014-05-18 11:13:57 +0900: Java8以前では関数を単純に引数として引き渡すことは出来なかった。
Comparatorとしてクラスにwrappingして、さらにインスタンスを生成してそれを渡さなければならない
これはとても不便だ。実際ソートする場所から離れて方法を定義しなければならない
2014-05-18 11:15:00 +0900: 　よりシンプルなやり方もあった。匿名クラスを宣言してそいつをインスタンスとして渡す方法だ。これならCollections.sortの引数として直接渡すことが出来る。
それでも上々なコードを書かなければならない。
2014-05-18 11:15:49 +0900: Java8なら冗長な書き方を削除できる。
Collections.sort(list, (Person p1, Person p2) -> p1.getName().compareTo(p2.getName()));
2014-05-18 11:18:03 +0900: 　Syntaxとしては、括弧に引数リスト、 -> のあとに実装を書く。
引数の型は省略することも出来る。コンパイラの型推論を利用する。ただし、Javaはあくまで静的な型付け言語であることを忘れてはならない。コンパイラが正確に推論できる必要がある
2014-05-18 11:19:17 +0900: 　コンパイラが型を推測できなければ無慈悲なコンパイルエラーとなる。
Comparatorにはcompare(T,T)というメソッドが定義されている。しかしラムダ式にはそれが定義されていない。
2014-05-18 11:20:05 +0900: 　ではどこで定義されているか？それがJava8で登場したFunctionalInterfaceである。
SingleFunction Interfaceの実装をFunctional Interfacesが提供する。
2014-05-18 11:22:04 +0900: 　FunctionalInterfacesは以前から提供されていた。e.g.Runnable#run() 常に1つのメソッドだけを持つという形になっている。
RunnableはFunctionalInterfaceなので、匿名クラスの代わりにラムダ式を使うことが出来る。Threadコンストラクタにラムダ式を渡せる
2014-05-18 11:22:45 +0900: 　パラメータがないので() -> System.out.println(hoge)となる。
2014-05-18 11:23:57 +0900: Functional Interfacesを使う新しいAPIをいくつか提供している。
e.g. List list = ...;
for (Person p : list) {
System.out.println(p);
}
新しいAPIであれば list.forEach(p -> System.out.println(p));と書ける
2014-05-18 11:25:51 +0900: 前ついの例がlist = Collections.synchronizedList(...);であると、大きな違いが出てくる。
for-each文ではイテレーターを使っている。hasNextとnextのメソッド呼び出しが毎回発生する。そのコール毎にsynchronizedされるが、その間はsynchronizedされていない
2014-05-18 11:26:10 +0900: synchronizedされていないときに要素が変更されてしまうとエラーになる。
2014-05-18 11:27:03 +0900: しかしlist.forEachでは、エレメントの処理中はロックしてくれ、処理が終わるまでロックし続けてくれる。
単純なforループであるが、違いが大きく出てくる
2014-05-18 11:27:56 +0900: もう1つのAPIの例：
for (Person p : list) {
if ("Jones".equals(p.getName()) {
ここでJonesを削除する方法は存在しなかった。
}
}
2014-05-18 11:28:29 +0900: 前ツイを実現するにはIteratorを古い方法で使うしかなかった。
2014-05-18 11:29:08 +0900: Iteratorをつかうシンプルな方法ではあるが、冗長的なコード記述が必要となってしまった。
2014-05-18 11:30:20 +0900: しかしJava8では新しく追加されたremoveIfを使うことで、このような形で書くエレメントを評価し、trueになった要素をListから除外することが出来る
list.removeIf(p -> "Jones".equals(p.getName()));
forループより明確に短く記述出来る
2014-05-18 11:31:46 +0900: さらに別の例では、StringのListに格納されているすべての要素を大文字にするには、以前はIterator#setを使う iter.set(iter.next().toUpperCase())
2014-05-18 11:32:56 +0900: Java8なら新しく追加されたreplaceAllメソッドですべての要素に対して実行するラムダ式を渡す list.replaceAll(s -> s.toUpperCase()); 新しい値で古い値がすべて置き換えられる
1つの引数でそれが実現できる
2014-05-18 11:34:31 +0900: s -> s.toUpperCase()という非常によくある処理だが、さらに単純に表すSyntaxがある。
list.replaceAll(String::toUpperCase); この場合、必ずしもs.toUpperCaseより優れているわけではないが、このmethod referenceを使った方がより明確に記述出来ることもある
2014-05-18 11:36:16 +0900: インタフェースに新しいメソッドが追加されたわけだが、後方互換性を考えるとJava7ではなかなか実装に踏み切れない。
Java8のフィーチャーとして、Default Methodがある。インタフェースで定義だけでなく実装をすることが出来る。
2014-05-18 11:38:18 +0900: Default Methodの例として、List.sort(lambda)
Java7ではソートはCollections.sort(list, Comparator)を用いていた。Listのあらゆる型に対してソート機能を提供するのがこれ。
Listの実装によって最適化するのはこいつでは難しかった。
2014-05-18 11:39:32 +0900: Java8ではlist.sortが実装され、Listインタフェースの実装クラスでデフォルト実装をオーバーライドすることが可能で、実装毎にソートを最適化することが出来る。
Collections.sortの一般的なソート実装よりも、より最適な方法で。
2014-05-18 11:40:52 +0900: コレクションに対して何らかの処理をする方法を紹介したが、元のコレクションを保持したままこれを行いたい。
Java7ではコレクションをコピーしたりしていたが、よくつかうのでStreamという新しい機能を提供する。
2014-05-18 11:42:18 +0900: Streamは0個以上の値をもち、実際に存在するかどうかわからず、順番があるのかどうか知らない。StreamはIteratorに似ていて、１つ１つの要素を扱うことができる。
もっとも重要な特徴として、Streamは並列に処理することも可能である。
2014-05-18 11:42:40 +0900: StreamAPIにおいてはパイプラインで複数の操作を行うことができる
2014-05-18 11:43:24 +0900: パイプラインは３つで構成される：ソース、中間操作（０以上）、そして終端操作
2014-05-18 11:43:50 +0900: すべてを紹介するのは時間が足りないので、いくつかに絞って紹介する。
2014-05-18 11:48:05 +0900: ４文字以上あるNameをソートするサンプル
List persons = ...;
persons.stream() // personsコレクションをstreamにする
.map(p -> p.getName()) // map操作でラムダ式を使う=>NameのStream
.filter(s->s.codePointCount(0, s.length()) > 3) // ラムダ式の結果がtrueであればそれを渡し、falseならStreamからDropされる
.sorted()
.forEach(System.out::println); // 終端操作。
2014-05-18 11:48:55 +0900: 別の終端操作ではこんな感じ
List persons = ...;
List sortedNames =
persons.stream() // personsコレクションをstreamにする
.map(p -> p.getName()) // map操作でラムダ式を使う=>NameのStream
.filter(s->s.codePointCount(0, s.length()) > 3) // ラムダ式の結果がtrueであればそれを渡し、falseならStreamからDropされる
.sorted()
.collect(Collectors.toList()): // 終端操作。
2014-05-18 11:51:32 +0900: PIを計算するテイラー級数の式ではこうなる
System.out.println(
LongStream.range(0L, 1_000_000_000L) // Long型のStream
.map(i -> ((i & 1) == 0 ? 1 : -1) * (2 * i + 1)) // 1, -3, 5, -7, ...の形になる式
.mapToDouble(i -> 4.0 / i) // mapで作った値を分母に持つdouble値にする
.sum()); // 終端操作。
2014-05-18 11:52:26 +0900: 並列化することで、マルチコアマシンで高速に処理することも可能
System.out.println(
LongStream.range(0L, 1_000_000_000L) // Long型のStream
.parallel()
.map(i -> ((i & 1) == 0 ? 1 : -1) * (2 * i + 1)) // 1, -3, 5, -7, ...の形になる式
.mapToDouble(i -> 4.0 / i) // mapで作った値を分母に持つdouble値にする
.sum()); // 終端操作。
2014-05-18 11:54:08 +0900: ラムダ式、StreamAPIについての説明、またかんれんして　Default Method, Method referencesについても説明した。
Streamを使うことで多くの処理を並列に処理することができ、ラムダ式とStreamAPIでコードがより明確な、そして簡潔に書くことができ、メンテナンスも容易になる
2014-05-18 12:55:56 +0900: /******* ここから #ccc_r13 **********/
2014-05-18 12:56:26 +0900: /*********** ここから #ccc_r11 *************/
2014-05-18 12:57:48 +0900: #ccc_r11 Future of Java EE with SE 8
by Mr. Hirofumi IWASAKI
Financial Service Departmnet, Development Unit
Rakuten Inc.
2014-05-18 12:58:29 +0900: もっと前に座ればよかったと今更後悔。もう移動する先がないのですorz
2014-05-18 12:58:53 +0900: 今更？最初に座ったとき(30分前)からずっと後悔してるよ
2014-05-18 12:58:57 +0900: ＿人＿
￣^￣
2014-05-18 12:59:18 +0900: こういうときは@Akkiesoftの爆発四散AAがいいよね
2014-05-18 12:59:40 +0900: 何だろうこのオフラインなのにつながってる感じ。クセになりそう
2014-05-18 13:00:59 +0900: JavaEEでSE8を使ううえでの制約についてまとめている感じのセッション
2014-05-18 13:01:34 +0900: Twitter: @hirofumiiwasaki (en)
2014-05-18 13:04:38 +0900: JavaEEとはなんぞや:APサーバーの仕様。
商用：Oracle WebLogic, WebSphere, JBoss, Interstage Cosminexus, etc....
OSS：WildFly, Liberty, etc...
2014-05-18 13:05:42 +0900: TransactionalになるようにEJB(JTA & CMT)
JPA(JDBC), JMS, RMI-IIOPで外部との通信、
JSF(Servlet & Facelet), JAX
2014-05-18 13:07:23 +0900: Java EEと.netFrameworkは大体同じ頃に生まれて競走（お互いにお互いをぱくる）を続けている感じ
2014-05-18 13:08:22 +0900: Java SEとEEは1年くらいずれている。EEが前提にしているJavaVMが1年前のSEをベースにしている感じ。
2014-05-18 13:09:23 +0900: Java EE７はSE8の仕様を知らないので、基本的にSE8に対応したEEは存在しない事になってる
2014-05-18 13:10:23 +0900: そもそもEE7に対応しているAPサーバーはGlassFishとWildFlyしかなく、デファクトスタンダードはJavaEE6。残念すぎる状況
2014-05-18 13:13:30 +0900: GlassFishはv4.0.1でJava 8をサポートする予定。Daily Buildではすでにサポートされている状況
2014-05-18 13:14:57 +0900: WebLogicはv12.1.4でJava8をサポートするらしい。但しだんだん遅れてきているので注意が必要
2014-05-18 13:15:14 +0900: 前ツイ < たぶん来年には使えてるんじゃない？
2014-05-18 13:18:31 +0900: JavaSE8の機能のうちEEに関係しそうな物：
Lambda, NewVM(ヒープとかPermanentとかのアレ), Date&Time, JavaFX, Type Annotation Improvement, Stream API, Unicode 6.2, Default Method, and others
2014-05-18 13:19:53 +0900: JavaSE8で無くなった物でEEに関係しそうな物：
JDBC-ODBC Bridge, com.sum.misc.*(BASE64で使うあたり)
2014-05-18 13:23:06 +0900: Lambda with Stream API：
.parallel: Automatic Parallel Threading
.forEachOrdered: 順番は守るforEach

Parallel StreamってEE7で動かないんじゃね？(後述
2014-05-18 13:24:27 +0900: Lambda Expressionsは覚えるまでは書くの面倒・・・

そこで、NetBeans先生なら自動変換できる！ "Use Functional Operation"
2014-05-18 13:25:42 +0900: New Date Time API:
Java 1.2 - Java 7: Calendar
Java 8: LocalDateTime 「普通これ出来るじゃろ」が出来るように

ナノ秒もとれるようになったよ
2014-05-18 13:27:26 +0900: New Date Time APIの計算処理も簡易に:
ある日付に対して3(日|月|時間|分|...)(足す|引く)が1行で出来るようになった
2014-05-18 13:27:54 +0900: ・・・いうてもEE7で使えない > 前ツイ
2014-05-18 13:29:53 +0900: New Date Time API on JDBC:
ANSI SQL, Java SE8
DATE, java.time.LocalDate
TIME, java.time.LocalDate
TIMESTAMP, java.time.LocalDateTime
TIME_WITH_TIMEZONE, java.time.OffsetTime ...
いうてEE7ではJPAの実装とかJDBCの実装待ちですよねー
2014-05-18 13:32:31 +0900: Type Annotation Improvement:
e.g. public String ooldStyle(String name, String pass) { if (name == null || pass == null) {...}} }
public String newStyle(@NotNull String name, @NotNull String pass)
-> ConstraintValidationException

よりわかりやすくバグやデータ異常を検出できる。GlassFishで利用可能
2014-05-18 13:34:28 +0900: SE8の適用ポイント:
やっぱりビジネスロジック(EJB、JTA)だよね
2014-05-18 13:37:00 +0900: もう一度注意点:
EE7はSE8を認識できない。SE8の機能を知らないんです。
機能によって動かないことがありますよっと
Stream API, New Date Time API(完全に動かん)
2014-05-18 13:45:11 +0900: EJB3.2は仕様でスレッドの制御を禁止している。GlassFishはなぜかparallelStreamを使えるが他のEEサーバーで使える保証はない

parallelStreamはFork/Join Frameworkで実装。こいつはもろにスレッドを利用している
2014-05-18 13:46:30 +0900: ほとんどのEE7サーバーはSE8を(基本的に)サポートしていない。
無理矢理使ったとして、うまく動くかどうかは保証されていないので、事前調査の元自己責任にて使いませう
2014-05-18 13:47:17 +0900: そのうちEE8も出てくるし、SE8の新機能を色々試してEE8に備えよう
2014-05-18 13:56:47 +0900: /************ ここから #ccc_h2 **************/
2014-05-18 13:57:44 +0900: Javaトラブルに備えよう
日本Javaユーザグループ 上妻 宣人
n-agetsuma.hatenablog.com
2014-05-18 14:03:53 +0900: Javaトラブルと言えば：
java.lang.OutOfMemoryError
＿人人人人人人人人＿
＞　突然の無応答　＜
￣^Y^Y^Y^Y^Y^Y^Y^￣ スローダウン、タイムアウト(SQL遅延、無限ループ、JTAタイムアウトなど
OS設定漏れ（Too many open filesなど
2014-05-18 14:05:05 +0900: ログがない、ダンプがない、プロファイラがアタッチできない、JXMつながらない、etc...ではどうしようもない。。。
トラブルに応じた情報収集がメインテーマ
2014-05-18 14:07:00 +0900: OutOfMemoryの備え：
予兆の確認－＞GCログの出力【負荷小】
発生時の解析－＞ヒープダンプ【負荷大】
－＞クラスヒストグラム【負荷中】
2014-05-18 14:08:09 +0900: GCログの出力：
Java起動オプションに設定すると、CGログがはき出される
ログ出力先、出力詳細レベル、ログに時刻を出力(デフォルトではJVM起動した時間からの経過秒数)
2014-05-18 14:12:45 +0900: ヒープダンプ:
負荷が大きいため注意。商用ではOOMエラー時自動取得がオヌヌメ
2014-05-18 14:16:29 +0900: クラスヒストグラム:
Javaヒープを多く占めているクラスを(多い順に)テキスト形式で取得出来る。

ヒープダンプもクラスヒストグラムもFull GCが走る。ヒープダンプよりクラスヒストグラムの方が負荷が少ないが、若干のダメージは覚悟する
2014-05-18 14:20:51 +0900: よくあるOOMエラー
1．突出型：ある機能を動かすとOOMErrorが発生する。DBやファイルからの大量ロードが原因
必要な情報：エラー字にどのコードが動いていたか(アプリログ)、OOMエラーが発生したタイミングのヒープダンプ
2014-05-18 14:23:34 +0900: 2．じわじわ型：長い時間をかけてOOMエラーに至る。再現に時間がかかるか、再現しないので非常に面倒。ORマッパーのキャッシュ、自作キャッシュ、セッション肥大化等が原因
必要な情報：時系列のヒープ情報(何がじわじわ増えているのか)　->定期的なクラスヒストグラムの収集。cronで定期的に収集するなど
2014-05-18 14:24:33 +0900: クラスヒストグラムの定期的な収集には、HeapStats(OSS)を利用すると便利。JVMにアタッチ、亭オーバーヘッドで自動収集してくれる。Flight Recorder的な動作
2014-05-18 14:26:03 +0900: 【スローダウン・タイムアウトに備える】
「応答がない？再起動しよう」－＞確実に迷宮入りです
スレッドダンプ(Javaスレッド状態)を出力してから再起動すること
2014-05-18 14:33:10 +0900: 無応答トラブル：
無限ループ： HashMap(マルチスレッド非対応)へのマルチスレッドアクセス->ConcurrentHashMapに変更する
SQLの応答待ち：コネクションプール枯渇を併発して、最悪全機能停止->SQL実行計画を確認、インデックス付与やSQL見直し。java.sql.setQueryTimeout(int)
※PostgreSQL~9.1はsetQueryTimeout未実装
2014-05-18 14:36:33 +0900: ある機能が遅いのはわかったが原因に当たりがつかない -> テスト対称で環境を動かしてhprofでプロファイリング。
hpref-CPU=samplesの特徴↓
よく動くスタックトレースをランキングで出力する。
※サンプリング時にアクティブなスレッドのみ集計する。sleep()やswait()による性能遅延は集計対象外
2014-05-18 14:37:55 +0900: 引っかかることの多いタイムアウト：
mod_jk: reply_timeout(worker.properties)タイムアウト時、502が返る
JTAトランザクションタイムアウト: タイムアウト後も止まらないケースがある
2014-05-18 14:38:59 +0900: JTAタイムアウト後も止まらないケース：
応答のないSQLクエリ受信待ちの場合、同期ソケットI/O中にinterrupt()に反応しないためとまらない
コネクションプールも逃避する要因なので注意
2014-05-18 14:39:51 +0900: WildFly8(JBoss)の場合、marked as zombieという形でWARNログを出力する。
SQLが返ってくるとゾンビスレッドを終了した旨のWARNログが出力される
2014-05-18 14:41:45 +0900: JTAタイムアウト対策：
JDBC SQLタイムアウトの設定：java.sql.statement.setQueryTimeout(int)　スレッド割り込みではなくキャンセル要求の送信で実現
APサーバー：WildFly8: 「set-tx-query-timeout」の設定
PostgreSQL 9.1以前では "set statement_timeout to "でなければ例外発生(未実装
2014-05-18 14:43:13 +0900: OSの設定漏れに備える：
Too many open files: FD枯渇？シンプルにclose漏れの可能性もある。UNIXならlsof -p で確認する
2014-05-18 14:44:00 +0900: unable to create new threadも同様：
スレッドダンプを取得して事実確認する
※このOOMエラーではヒープダンプはとられない
2014-05-18 14:45:26 +0900: 状況によってはググれない事もある（外部通信機器を持ち込めないサーバールーム、顧客に囲まれる等）。ちゃんと方法を覚えておこう
2014-05-18 14:57:57 +0900: /******* ここから #ccc_h3 ***********/
2014-05-18 14:58:09 +0900: マサカリ禁止ｗｗｗｗｗｗ
2014-05-18 15:01:22 +0900: 初めてのJavaEE開発から学んだこと
菊田 洋一
@kikutaro_
株式会社構造計画研究所
2014-05-18 15:09:49 +0900: 日本は最新の書籍がない。そもそもJavaEE本がない。
海外だとめっちゃある
2014-05-18 15:10:04 +0900: 本と日本語の情報少ないよねー
2014-05-18 15:10:07 +0900: ほんと
2014-05-18 15:24:04 +0900: JavaEEは仕様を提供するだけなので、実装を取捨選択していくことが重要。
「こんなの見つけたけど、どう思う？」という会話からの新技術開拓にも
2014-05-18 15:30:35 +0900: よく聞く話：
JSFはダメ、JSFはコンポーネントツリーを抱えるので性能面で注意
O/Rマッパーはパフォーマンスを含めてはまりやすい、JPQLでDBベンダを意識せず開発できるけど、実際DB切り替えることはないんじゃない？
2014-05-18 15:30:51 +0900: ＿人人人人人人人人人人人＿
＞　標準がdisられる世界　＜
￣^Y^Y^Y^Y^Y^Y^Y^Y^Y^Y^￣
2014-05-18 15:33:01 +0900: JSF: HTTPを意識しない抽象化が行き過ぎている。サーバーサイドで生成されるHTMLが読みにくい(3rd Partyのライブラリを利用した場合など)。デバッグがむずい(メッセージがわからん)。
Technology Rader 2014でもJSFはHOLD(先行きがわからないので慎重に)
2014-05-18 15:34:15 +0900: JSFの良い点: PriceFacesのような立地UIコンポーネントを利用することで、
・JSエンジニアが居なくても複雑なコンポーネントを利用できる
・デザイナが居ないチームでも見栄えの良い画面を提供できる

2014-05-18 15:35:17 +0900: JSFの良い点: 利用可能なコンポーネントを設計時から共有することで、技術的なずれや機能レベルの認識あわせが出来る
2014-05-18 15:37:29 +0900: JSF,JPAの性能面の問題対策:
JSFはSessionScopeやApplicationScopeを多用せずスコープを意識する。大量のコンポーネントを配置しないように
JPAは開発中はログ出力して、実クエリの発行回数など注意する。
2014-05-18 15:41:39 +0900: JPQLを利用してよかったと思える例:
イントラ外、オフラインで見積もり可能な感じにしたい。エンドユーザーのPCが対称、インストール、メンテナンスを出来るだけ軽減。開発コードはなるべく同じに。
->Embedded GlassFish+組み込みデータベース(オンラインシステムはMSSQL, オフラインシステムはDerby)で簡単にインストール・メンテ
->SQLはJPQLで差異をJPAに吸収させる
->オフライン、オンライン両システムはJAX-RS,JSONでsync
2014-05-18 15:54:55 +0900: /************ ここから #ccc_h4 ****************/
2014-05-18 15:55:16 +0900: 電源確保ーこれで残りのセッションも安心だね!
2014-05-18 16:00:47 +0900: Javaデバッガ活用術
勘デバッグ・printデバッグから抜けだそう
山本 祐介 @yusuke
株式会社サムライズム
2014-05-18 16:04:03 +0900: デバッグの難易度は開発フェーズが後ろに行けば行くほど高くなる。手前であっても後ろであってもデバッガを活用しよう
2014-05-18 16:05:11 +0900: ユニットテスト：インプットに対して期待するアウトプットが出るかどうか
デバッガ：期待通りに動いて"いない"実装を掘り下げる。大量のdebug/print文
でコードを汚さないこと
2014-05-18 16:07:23 +0900: デバッグ目的でユニットテストを作成すると粒度が細かくなりすぎる。ユニットテストは機能単位のテストになるべきではないです？
ユニットテストはリグれっしょんを発見できる最低限のセットで納めておくと吉
ロジックの確認・デバッグはあくまでデバッガのお仕事
2014-05-18 16:08:27 +0900: デバッグ方法：
再現条件の確認<-難しい<=デバッガ使おう
テストケースの作成
当該コードの修正
2014-05-18 16:09:44 +0900: デバッガのお仕事：
プログラムを任意の箇所で一時停止(ブレーク)
ステップ実行
即時評価
値や処理の書き換え
etc...
2014-05-18 16:11:24 +0900: デバッガのお仕事じゃないこと：
ボトルネックの発見
タイミングissue(たまに問題が発生する)の原因究明
結合箇所の問題発生
2014-05-18 16:13:58 +0900: 行ブレークポイント・ステップ実行：
指定した行に到達するとプログラムが一時停止、1行ずつ順次実行

step over: 現在のクラスをステップ
step into: 呼び出し先に潜り込んでステップ

resume/continue: ブレーク中のスレッドを再開し、次のブレークポイントまで動作
2014-05-18 16:24:53 +0900: ブレークポイントのよくある問題：ループ内をデバッグするとき、問題発生まで何回もブレークしてしまうorz
＝＞ヒットカウント/条件付きブレークポイントを使おう
2014-05-18 16:25:24 +0900: 条件付きブレークカウントの使い方：IDE毎に異なるが、大体ブレークポイント右クリックしてプロパティ見て設定すればOK
2014-05-18 16:28:54 +0900: 条件付きブレークポイント：回数や特定の変数の内容によってブレークするかどうかを設定できる
2014-05-18 16:32:00 +0900: リモートデバッグ：JPDA（Java Platform Debug Architecture）
IDE内外でデバッガをアタッチする為に使う
実行オプションでListenポートやデバッガアタッチまで待つかどうかを指定する
2014-05-18 16:40:35 +0900: プロダクション環境のデバッグの注意点：
パフォーマンス：処理が止まるので注意。デバッグ有効化はパフォーマンスに影響なし、アタッチ時は影響有り。頻繁に処理がある機能でブレークするときは要注意
セキュリティ：めっちゃ脆弱(任意のコードを実行可能)。認証機構はない。ｙ\不要な場合は無効にし、プロダクション環境ではListenアドレスを指定する e.g. "localhost;5005"
リモートでバッグはsshトンネル経由でやればある程度は安心
2014-05-18 16:42:31 +0900: デバッグあるある：
「ここだ！」とブレークポイント設定->事件はそれ以前->もっと前に設定->step over...->行き過ぎた！
CIのみ
たまにしか再現しない
print分入れたら再現しない
再現条件がわからない
2014-05-18 16:45:51 +0900: 前ツイを何とかするには超能力が必要。
超能力を使えないならChronon Timetraveling Debuggerを使ってみよう(実行状況(ローカル変数、フィールドの変更履歴を含めて)を保存し、後から確認できる)
2014-05-18 16:46:43 +0900: Chronon Timetraveling Debugger、言ったり来たり出来るからすっげー楽しそう
2014-05-18 16:47:16 +0900: Chronon(ry) IntelliJ IDEAをもっていれば無料だってよ
2014-05-18 16:48:01 +0900: プロダクション環境ならChronon Recording Serverで記録し続けてローテートすることが出来る。パフォーマンスオーバーヘッドは低い
2014-05-18 16:48:37 +0900: 記録したいパッケージ・クラスを設定しておけば無駄な記録をとらなくても済む
2014-05-18 16:50:37 +0900: デバッガを使いこなせれば、デバッグ職人が不要になるよ
2014-05-18 16:55:52 +0900: /******** ここから #ccc_r15 **************/
2014-05-18 16:58:26 +0900: JavaEE7対応! JPAの同時実行制御とロック
多田 真敏
株式会社ウチダ人材開発センタ
2014-05-18 16:59:07 +0900: @suke_masa
2014-05-18 17:07:42 +0900: JPAのロック：
楽観的ロック(OPTIMISTIC)：更新対称に対して、他のトランザクションから更新がないという前提で行うロック。悲観的ロックよりハイパフォーマンス
悲観的ロック(PRESIMISTIC)：更新対称にロックをかけて他のトランザクションからの更新をDBMSが防ぐ。

楽観的ロックはDBMS機能を使わず、悲観的ロックはDBMS機能を使う
2014-05-18 17:08:58 +0900: バージョニング：バージョンを表す列を対称テーブルに追加、エンティティクラスのバージョンフィールドに@Versionアノテーションを負荷。int,short,long,java.sql.TimeStamp
更新時に@Versionが更新される
2014-05-18 17:10:27 +0900: enum LockModeType:
楽観的/悲観的ロック、READ/WRITEロック、バージョン値を更新する、ロックしないを指定するenum値。
EntityManagerインタフェースのfind, lock, refreshメソッドなどで指定する
2014-05-18 17:11:08 +0900: ちなみに金魚本では、同時実行は6ページ、悲観的ロックは半ページ程度。JavaEE5では楽観的ロックしかなかったため、扱いが軽かったのでは？と推測
2014-05-18 17:19:59 +0900: EclipseLink x MySQL + LockModeType.NONE => (つд⊂)
EclipseLink x MySQL + LockModeType.OPTIMISTIC => javax.persistence.OptimisticLockException 取得した時点と比較してDBのレコードがすでに更新されているため例外発生してロールバック ロールバックされたエンティティもバージョン値がインクリメントされる(@maruTA_bis5 注: 新しいレコードの内容がセットされているだけでは？
2014-05-18 17:20:49 +0900: JPAのバージョン地変更の検知：UPDATE文のWHERE句に主キーとバージョン列を指定している->バージョン値がすでに変更されていた場合、更新行数は0行となるため例外が創出できる
2014-05-18 17:21:24 +0900: EclipseLink + OPTIMISTIC_FORCE_INCREMENT => OPTIMISTICと全く同じ結果
2014-05-18 17:26:21 +0900: EclipseLink x MySQL + PRESSIMISTIC_READ => SELECT FOR UPDATE文が実行され、"WRITE"ロックを取得する。(バージョニング不要
SQLログはJPAがDBMSに発行した「つもり」のSQLが記録される。ログに記録されていても実際はDBMSの待ち行列にいる可能性がある
2014-05-18 17:26:53 +0900: EclipseLink + PESSIMISTIC_WRITE => PESSIMISTIC_READと同様
2014-05-18 17:28:19 +0900: EclipseLink x MySQL + PESSIMISTIC_FORCE_INCREMENT => 強制的にバージョン値がインクリメント。JSRではexclusive lock(=WRITE)であると記載されているがチュートリアルには記載されていないので注意
2014-05-18 17:29:19 +0900: EclipseLink x PostgreSQL => EclipseLink x MySQLと同じ挙動
2014-05-18 17:29:56 +0900: Hibernate x MySQL + NONE => (つд⊂)　SQLは微妙に異なるらしい
2014-05-18 17:31:07 +0900: Hibernate x MySQL + OPTIMISTIC => ロールバックされたエンティティのバージョンはインクリメントされない(@maruTA_bis5 注: 単純にエンティティが更新されないんじゃないかと思ったらsalが上がってる。単純に更新前の状態に戻っただけでしょう
2014-05-18 17:32:59 +0900: 前ツイ> バージョンを取得するために更新をかけたトランザクションからSELECT文をもう1回発行する。
2014-05-18 17:33:34 +0900: Hibernate x MySQL + OPTIMISTIC_FORCE_INCREMENT => flushとcommitの2回、バージョンがインクリメントされる。前ツイのSELECTによるバージョン確認は行わない
2014-05-18 17:36:46 +0900: Hibernate x MySQL + PESSIMISTIC_READ => LOCK IN SHARE MODE文でREAD LOCKが取得される => デッドロックが発生する(つд⊂) -> 片方はロールバックされ、もう片方がコミットされる
2014-05-18 17:38:03 +0900: 前ツイ> 2本のトランザクションが互いにREAD LOCKをもっている状態で、UPDATEクエリを発行しようとしたらそりゃデッドロックになりますわ
2014-05-18 17:38:39 +0900: Hibernate x MySQL + PESSIMISTIC_WRITE => SELCT FOR UPDATE文でちゃんと動く
2014-05-18 17:39:36 +0900: Hibernate x MySQL + PESSIMISTIC_FORCE_INCREMENT => SELECT FOR UPDATE文でWRITEロックが取得、ちゃんとコミットできる。後は例の2回バージョン更新が発生
2014-05-18 17:41:08 +0900: Hibernate x PostgreSQL => PESSIMISTIC_FORCE_INCREMENTのみHibernate x MySQLと挙動が異なる
READ LOCKはSELECT FOR SHARE文
2014-05-18 17:43:17 +0900: Hibernate x PostgreSQL + PESSIMISTIC_FORCE_INCREMENT => SELECT FOR UPDATE文にNOWAITが負荷される。
後からのトランザクションは【待つことが出来ない】為、即座に例外が発生する
2014-05-18 17:45:17 +0900: Hibernate + PESSIMISTIC_READについて: 書き換えるってわかってるんだし、最初からWRITEロックとれよ (@maruTA_bis5)
2014-05-18 17:51:23 +0900: /******************* ここから #ccc_r16 *********************/
2014-05-18 17:52:19 +0900: 座りっぱなしでそろそろ体が悲鳴を上げてきているので、このセッションが終わったら返ろう
2014-05-18 17:54:23 +0900: Modern Java Web Development
Takuro MONJI
Simplex Inc.
2014-05-18 17:59:13 +0900: ※「このセッションは実例と個人の主観で構成されています」アナウンスはいりましたー
2014-05-18 18:00:17 +0900: 最近のSPA事例紹介 @monzou Simplex Inc, Financial Application Developer
2014-05-18 18:02:17 +0900: モダンなJava, Java+SPA、プロジェクト全体感がわかるような資料・実例があまり出回っていないので、たまたま公開したらバズる
2014-05-18 18:02:46 +0900: 。○（事例ベースなので後でゆっくりスライドを見よう）
2014-05-18 18:04:59 +0900: 既存Webシステムの問題点
・"構造"の欠落
Ajax化に伴うフラグメント化、業務レイヤの独立性が担保できぬ
・クライアントの進歩について行けない
クライアントとサーバーの密結合で、独立して開発するのが難しい

2014-05-18 18:06:00 +0900: そこでSinglePageApplication
クライアントとサーバーを分離したい
ステートフルなJS+REST API
リッチ化が進むB2C案件のために、ナレッジを蓄積したい
2014-05-18 18:10:19 +0900: ポイント：
クライアントやAPIは容易に変化するが、ドメインモデルは容易に変化しない。独立性を保つ
2014-05-18 18:11:56 +0900: GradleはMavenと違って何も知らなくても勝手に良い感じのビルド環境が手に入るので良いよ
2014-05-18 18:28:23 +0900: Bean Validation(JSR-303) どうです？
複雑なことをしようとすると汚くなる
コードの見通しが悪い
etcetc...
2014-05-18 18:49:03 +0900: SPA開発は"普通"の延長線上。APIとクライアントが違うだけ。
でもまだまだ発展途上の分野。
複雑化してくる傾向はあるが、出来るだけ単純な形を保つ
```